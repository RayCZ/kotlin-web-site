---
type: doc
layout: reference
category: "Syntax"
title: "Type-Safe Builders"
---

# Type-Safe Builders

Type-Safe Builders ：類型-安全建造者模式

By using well-named functions as builders in combination with [function literals with receiver](lambdas.html#function-literals-with-receiver) it is possible to create type-safe, statically-typed builders in Kotlin.

透過使用好的命名函數作為建構者模式與使用 receiver 的函數文字結合，可以在 Kotlin 建立類型安全、靜態類型的建造者模式。

Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:

類型安全建造者模式允許建立 Kotlin 為基礎的領域特定語言 (DSL) ，適合以半宣告的方式建立複雜層級的資料結構。建造者模式的一些使用範例：

* Generating markup with Kotlin code, such as [HTML](https://github.com/Kotlin/kotlinx.html) or XML;
  使用 Kotlin 代碼生成標記，例如： [HTML](https://github.com/Kotlin/kotlinx.html) 或 XML ；
* Programmatically laying out UI components: [Anko](https://github.com/Kotlin/anko/wiki/Anko-Layouts)
  編碼做 UI 元件排版： [Anko](https://github.com/Kotlin/anko/wiki/Anko-Layouts)
* Configuring routes for a web server: [Ktor](http://ktor.io/features/routing.html#routing-tree).
  配置 web server 的路由：[Ktor](http://ktor.io/features/routing.html#routing-tree) 。

## A type-safe builder example

A type-safe builder example ：類型安構建造者模式範例

Consider the following code:

考慮以下代碼：

``` kotlin
import com.example.html.* // see declarations below

fun result(args: Array<String>) =
    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
        body {
            h1 {+"XML encoding with Kotlin"}
            p  {+"this format can be used as an alternative markup to XML"}

            // an element with attributes and text content
            a(href = "http://kotlinlang.org") {+"Kotlin"}
    
            // mixed content
            p {
                +"This is some"
                b {+"mixed"}
                +"text. For more see the"
                a(href = "http://kotlinlang.org") {+"Kotlin"}
                +"project"
            }
            p {+"some text"}
    
            // content generated by
            p {
                for (arg in args)
                    +arg
            }
        }
    }
```

This is completely legitimate Kotlin code. You can play with this code online (modify it and run in the browser) [here](https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder).

這是完全合法的 Kotlin 代碼。你可以在線上玩這個代碼 (在瀏覽器修改它並執行) [這裡](https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder)。

## How it works

How it works ：它如何運作

Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, `HTML` is a class that describes the `<html>` tag, i.e. it defines children like `<head>` and `<body>`. (See its declaration [below](#full-definition-of-the-comexamplehtml-package).)

讓我們看看在 Kotlin 中實作類型安全建造者的機制。首先，我們需要定義我們想要建立的模型，在這種情況下，我們需要做 HTML 標籤建模。使用類型分支很容易完成。例如： `HTML` 是類型並描述在 `<html>` 標籤，換句話說，它定義的後代像 `<head>` 和 `<body>` 。 (閱[下面](#full-definition-of-the-comexamplehtml-package)的宣告)

Now, let's recall why we can say something like this in the code:

現在，讓我們回想我們為何可以在代碼中說出這樣的話：

``` kotlin
html {
 // ...
}
```

`html` is actually a function call that takes a [lambda expression](lambdas.md) as an argument. This function is defined as follows:

`html` 實際上是一個函數調用，帶 [Lambda 表達式](lambdas.md)為參數。函數被定義如下： 

``` kotlin
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML() // 建造實例
    html.init() // 調用函數 {...}
    return html // 回傳實例
}
```

This function takes one parameter named `init`, which is itself a function. The type of the function is `HTML.() -> Unit`, which is a _function type with receiver_. This means that we need to pass an instance of type `HTML` (a _receiver_) to the function, and we can call members of that instance inside the function. The receiver can be accessed through the *this* keyword:

這個函數帶命名 `init` 參數，參數本身是一個函數。函數類型是 `HTML.() -> Unit` ， 是使用 receiver 的函數類型。這意味著我們需要傳遞類型 `HTML` (一個 recever) 的實例給函數，以及我們可以在函數內調用該實例的成員。可以透過 `this` 關鍵字存取 receiver 。

**receiver ：代表一個實例 (手動產生或被動產生)**

``` kotlin
// 由於在 Kotlin 的 lambda 表示法，符號 {} 這個所代表一個函數
// 編譯器無法從之中得到任何的類型資訊，所以才用 receiver 宣告類型
html { // 函數內，被動產生 HTML 類型的實例
    this.head { ... } // 調用 html 的成員 head
    this.body { ... } // 調用 html 的成員 body
}
```

(`head` and `body` are member functions of `HTML`.)

(`head` 和`body` 是 `HTML` 的成員函數。)

Now, *this* can be omitted, as usual, and we get something that looks very much like a builder already:

現在， `this` 可以像往常被省略，以及我們取得的東西看起來非常像建造者：

``` kotlin
html {
    head { ... } // 省略 this
    body { ... } // 省略 this
}
```

So, what does this call do? Let's look at the body of `html` function as defined above. It creates a new instance of `HTML`, then it initializes it by calling the function that is passed as an argument (in our example this boils down to calling `head` and `body` on the `HTML` instance), and then it returns this instance. This is exactly what a builder should do.

所以，這個調用做什麼事？讓我們看看上面定義的 `html` 函數的內文。它建立一個新的  `HTML` 實例，接著調用它透過作為參數傳遞的函數來初始化實例 (在我們的範例中，這歸類為在 `HTML` 實例上調用 `head` 和 `body`) ，然後它回傳這個實例。這正是建造者模式該做的事。

The `head` and `body` functions in the `HTML` class are defined similarly to `html`. The only difference is that they add the built instances to the `children` collection of the enclosing `HTML` instance:

在 `HTML` 類別中 `head` 和 `body` 函數定義與 `html` 相似。唯一不同的是它們添加建造的實例給封閉  `HTML` 實例中 `children` 集合：

``` kotlin
fun head(init: Head.() -> Unit) : Head {
    val head = Head()
    head.init()
    children.add(head) // 添加給 html
    return head
}

fun body(init: Body.() -> Unit) : Body {
    val body = Body()
    body.init()
    children.add(body) // 添加給 html
    return body
}
```

Actually these two functions do just the same thing, so we can have a generic version, `initTag`:

實際上那兩個函數做相同的事情，所以我們可以有泛型版本， `initTag` ：

``` kotlin
protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
    tag.init()
    children.add(tag)
    return tag
}
```

So, now our functions are very simple:

所以，現在我們的功能非常簡單：

``` kotlin
fun head(init: Head.() -> Unit) = initTag(Head(), init)

fun body(init: Body.() -> Unit) = initTag(Body(), init)
```

And we can use them to build `<head>` and `<body>` tags. 

以及我們可以使用它們來建造 `<head>` 和 `<body>` 標籤。

One other thing to be discussed here is how we add text to tag bodies. In the example above we say something like:

這裡討論的另一件事是我們如何添加文字給標籤內文。在上面的例子中，我們說的是：

``` kotlin
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
```

So basically, we just put a string inside a tag body, but there is this little `+` in front of it, so it is a function call that invokes a prefix `unaryPlus()` operation. That operation is actually defined by an extension function `unaryPlus()` that is a member of the `TagWithText` abstract class (a parent of `Title`):

所以基本上，我們只是在一個標籤內文中放一個字串，但它前面有一個小 `+` ，所以它是調用前綴 `unaryPlus()` 操作的函數調用。該操作實際上透過擴展函數 `unaryPlus()` 定義，該函數是 `TagWithText` 抽象類別 ( `Title` 的父親) 的成員。

``` kotlin
operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
```

So, what the prefix `+` does here is wrapping a string into an instance of `TextElement` and adding it to the `children` collection, so that it becomes a proper part of the tag tree.

所以，前綴 `+` 在這裡做包裝字串給 `TextElement` 的實例並添加它到 `children` 集合，以便它變成標籤樹的適當部分。

All this is defined in a package `com.example.html` that is imported at the top of the builder example above. In the last section you can read through the full definition of this package.

所有這些被定義在 package `com.example.html` ，在建造者上面範例的最上面匯入。在上一個章節你可以閱讀此 `package` 的完整定義。

## Scope control: @DslMarker (since 1.1)

Scope control: @DslMarker (since 1.1) ：範圍控制：@DslMarker (從 1.1)，利用我們類別的繼承關係變成 DSL 使用的階層

>**Tag ：標籤，用於 HTML 的語法 <...>**

> **Marker ：記號，用於在程式碼做 DSL 的記號**

> **Annotation ：註釋，用於程式碼做帶有 @ 符號的註釋**

When using DSLs, one might have come across the problem that too many functions can be called in the context. We can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag `head` inside another `head`: 

當使用 DSL 時，可能會碰到在內文中調用太多函數的問題。我們可以在 Lambda 內調用每個可用隱性 receiver 的方法 (沒有階層的限制)，因此取得不一致的結果，像是另一個 `head` 內的標籤 `head` ：

``` kotlin
html {
    head {
        head {} // should be forbidden , 因為 head 沒有做階層的限制，例如： html > head or body
    }
    // ...
}
```

In this example only members of the nearest implicit receiver `this@head` must be available; `head()` is a member of the outer receiver `this@html`, so it must be illegal to call it.

在這個範例中，只有在 `html{...}` 內最近隱性 receiver `this@head` 的成員必須可用的； `head()` 是外部 receiver `this@html` 的成員，所以上面範例它一定是非法調用它。

To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced.

為了解決這個問題，在 Kotlin 1.1 引入一個特別機制去控制 receiver 範圍。

To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders we declare an annotation `@HTMLTagMarker`:

為了使編譯器開始控制範圍，我們只需要在使用相同標記註釋的 DSL 中註記所有 receiver 類型。例如 ：對於 HTML 建造者，我們宣告註釋 `@HTMLTagMarker` ：

``` kotlin
@DslMarker
annotation class HtmlTagMarker // 宣告一個新的註釋 @HtmlTagMarker (DSL 記號) 用來區分 HTML 的階層
```

An annotation class is called a DSL marker if it is annotated with the `@DslMarker` annotation.

如果使用 `@DslMarker` 註釋註記類別，註釋類別被稱為 DSL 記號。

In our DSL all the tag classes extend the same superclass `Tag`. It's enough to annotate only the superclass with `@HtmlTagMarker` and after that the Kotlin compiler will treat all the inherited classes as annotated:

在我們的 DSL 中，所有的標籤類別 (html 、 head 、  body) 繼承相同的超 (父) 類別 `Tag`。只註記超 (父) 類別使用 `@HtmltagMarker` 就足夠了，以及之後在 Kotlin 編譯器將視所有的繼承類別為註釋：

``` kotlin
@HtmlTagMarker
abstract class Tag(val name: String) { ... }
```

We don't have to annotate the `HTML` or `Head` classes with `@HtmlTagMarker` because their superclass is already annotated:

我們不必使用 `@HtmlTagMarker` 註記 `HTML` 或 `Head` ，因為它們的超 (父) 類別已經是被註記的 (類別的繼承關係來建立)：

```
class HTML() : Tag("html") { ... }
class Head() : Tag("head") { ... }
```

After we've added this annotation, the Kotlin compiler knows which implicit receivers are part of the same DSL and allows to call members of the nearest receivers only: 

在我們已經添加這個註釋後， Kotlin 編譯器知道隱性的 receiver 是相同 DSL 的一部分以及只允許調用最近 receiver 的成員：

``` kotlin
html { // Tag("html")
    head { // Tag("head")
        head { } // error: a member of outer receiver , 只能調用 head 的成員
    }
    // ...
}
```

Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:

注意：它仍然可以調用外部的 receiver 成員，但要做到這點，你必須明確指定 `this` 的 receiver ：

``` kotlin
html {
    head {
        this@html.head { } // possible , @html.head 明確指定是在 html 下的 head 實例
    }
    // ...
}
```

## Full definition of the `com.example.html` package

Full definition of the `com.example.html` package ： `com.example.html` package 的完整定義

This is how the package `com.example.html` is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of [extension functions](extensions.md) and [lambdas with receiver](lambdas.md#function-literals-with-receiver).

這是如何定義 `com.example.html` package (只限上面範例中使用的元素) 。 它建立 HTML 樹。它大量使用[擴展函數](extensions.md)和[使用 receiver 的 Lambda 表示法](lambdas.md#function-literals-with-receiver)。

Note that the `@DslMarker` annotation is available only since Kotlin 1.1.

注意： `@DslMarker` 註釋只從 Kotlin 1.1 版可用。

``` kotlin
package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent$text\n")
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf<Element>()
    val attributes = hashMapOf<String, String>()

    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }
    
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent<$name${renderAttributes()}>\n")
        for (c in children) {
            c.render(builder, indent + "  ")
        }
        builder.append("$indent</$name>\n")
    }
    
    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(" $attr=\"$value\"")
        }
        return builder.toString()
    }
    
    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, "")
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText("html") {
    fun head(init: Head.() -> Unit) = initTag(Head(), init)

    fun body(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head : TagWithText("head") {
    fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title : TagWithText("title")

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -> Unit) = initTag(B(), init)
    fun p(init: P.() -> Unit) = initTag(P(), init)
    fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag("body")
class B : BodyTag("b")
class P : BodyTag("p")
class H1 : BodyTag("h1")

class A : BodyTag("a") {
    var href: String
        get() = attributes["href"]!!
        set(value) {
            attributes["href"] = value
        }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```